<!DOCTYPE html><html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>RNA-Seq Power Calculator v2.2</title>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>
    body {
      background: #111;
      color: #eee;
      font-family: sans-serif;
      padding: 20px;
      max-width: 1000px;
      margin: auto;
    }
    input, select, button {
      margin: 5px;
      padding: 6px;
      background-color: #222;
      color: #fff;
      border: 1px solid #444;
      border-radius: 4px;
    }
    h2 { color: #90caf9; }
    .output { margin-top: 15px; font-weight: bold; }
    .legend-box {
      margin-top: 40px;
      padding: 1em;
      background: #1b1b1b;
      border: 1px solid #333;
    }
    .plot-section { margin-top: 30px; }
    .alert-ok { color: #66ff66; font-weight: bold; }
    .alert-bad { color: #ff6666; font-weight: bold; }
  </style>
</head>
<body>
  <h2>RNA-Seq Power Calculator v2.2 (DESeq2 Model)</h2><label>Mean expression (μ): <input type="number" id="mu" value="100"></label><br> <label>Dispersion (α): <input type="number" id="dispersion" value="0.1" step="0.01"></label><br> <label>log2 fold change (Δ): <input type="number" id="lfc" value="1" step="0.1"></label><br> <label>Replicates per group (≥3): <input type="number" id="n" value="3" min="3"></label><br> <label>Target FDR: <input type="number" id="fdr" step="0.01" value="0.05" min="0.001"></label><br> <label>Number of isoforms (m): <input type="number" id="m" value="20000"></label><br> <label>Target rank (i): <input type="number" id="rank" value="1000" min="1"></label><br> <label>Target power (optional): <input type="number" id="targetPower" step="0.05" value="0.8" min="0.1" max="1.0"></label><br><br>

<button onclick="calculate()">Estimate Power</button> <button onclick="estimateRequiredSamples()">Estimate Samples for Target Power</button>

  <div class="output" id="result"></div>
  <div class="output" id="fdrEstimation"></div>
  <div class="output" id="requiredSamples"></div>  <div class="plot-section">
    <div id="powerVsN"></div>
    <div id="powerVsMu"></div>
    <div id="powerVsLFC"></div>
    <div id="powerVsDisp"></div>
  </div>  <div class="legend-box">
    <h3>Methodology & Formulas</h3>
    <ul>
      <li><strong>Model:</strong> DESeq2 (Negative Binomial): <code>Var(Y) = μ + α·μ²</code></li>
      <li><strong>SE of log2FC:</strong> <code>SE = sqrt((2 / n) × Var / μ²)</code></li>
      <li><strong>Test statistic:</strong> <code>Z = |Δ| / SE</code></li>
      <li><strong>Per-test significance level:</strong> <code>α = (FDR × i) / m</code></li>
      <li><strong>Power:</strong> <code>Φ(Z − Zₐ)</code> where Zₐ = <code>Φ⁻¹(1 − α)</code></li>
      <li><strong>Target rank (i):</strong> Your position in BH-ranked tests</li>
      <li><strong>Target power:</strong> Desired detection probability (e.g., 0.8)</li>
      <li><strong>Used parameters:</strong> μ – expression level, Δ – effect size, α – dispersion, n – replicates, m – tests</li>
    </ul>
  </div>  <script>
    function normCdf(z) {
      return 0.5 * (1 + erf(z / Math.sqrt(2)));
    }
    function erf(x) {
      const sign = x >= 0 ? 1 : -1;
      x = Math.abs(x);
      const t = 1 / (1 + 0.5 * x);
      const y = 1 - t * Math.exp(-x*x - 1.26551223 +
        t * (1.00002368 + t * (0.37409196 + t * (0.09678418 +
        t * (-0.18628806 + t * (0.27886807 + t * (-1.13520398 +
        t * (1.48851587 + t * (-0.82215223 + t * 0.17087277)))))))));
      return sign * y;
    }
    function inverseErf(x) {
      const a = 0.147;
      const ln = Math.log(1 - x * x);
      const term1 = (2 / (Math.PI * a)) + (ln / 2);
      const term2 = ln / a;
      return Math.sign(x) * Math.sqrt(Math.sqrt(term1 * term1 - term2) - term1);
    }

    function calculate() {
      const mu = parseFloat(document.getElementById("mu").value);
      const alpha = parseFloat(document.getElementById("dispersion").value);
      const lfc = parseFloat(document.getElementById("lfc").value);
      const n = Math.max(3, parseInt(document.getElementById("n").value));
      const fdr = parseFloat(document.getElementById("fdr").value);
      const m = parseInt(document.getElementById("m").value);
      const rank = parseInt(document.getElementById("rank").value);
      const targetPower = parseFloat(document.getElementById("targetPower").value);

      const alphaTest = (fdr * rank) / m;
      const z_alpha = inverseErf(1 - alphaTest) * Math.sqrt(2);
      const variance = mu + alpha * mu * mu;
      const se = Math.sqrt((2 / n) * variance / (mu * mu));
      const z = Math.abs(lfc) / se;
      const power = normCdf(z - z_alpha);

      let resultText = `Estimated power: ${(power * 100).toFixed(1)}%`;
      if (targetPower && power < targetPower) {
        resultText += ` — Below target power of ${(targetPower * 100).toFixed(0)}%. Consider increasing replicates, μ or Δ.`;
      }

      document.getElementById("result").innerText = resultText;
      document.getElementById("fdrEstimation").innerText = `Effective per-test α derived from FDR=${fdr}, rank=${rank}, m=${m}: ${(alphaTest * 100).toExponential(2)}%`;

      drawPowerVsN(mu, alpha, lfc, fdr, rank, m);
      drawPowerVsMu(n, alpha, lfc, fdr, rank, m);
      drawPowerVsLFC(n, mu, alpha, fdr, rank, m);
      drawPowerVsDisp(n, mu, lfc, fdr, rank, m);
    }

    function estimateRequiredSamples() {
      const mu = parseFloat(document.getElementById("mu").value);
      const alpha = parseFloat(document.getElementById("dispersion").value);
      const lfc = parseFloat(document.getElementById("lfc").value);
      const fdr = parseFloat(document.getElementById("fdr").value);
      const m = parseInt(document.getElementById("m").value);
      const rank = parseInt(document.getElementById("rank").value);
      const targetPower = parseFloat(document.getElementById("targetPower").value);

      if (!targetPower || targetPower < 0.1 || targetPower >= 1.0) {
        document.getElementById("requiredSamples").innerText = "Please specify a valid target power between 0.1 and 0.99.";
        return;
      }

      const alphaTest = (fdr * rank) / m;
      const z_alpha = inverseErf(1 - alphaTest) * Math.sqrt(2);
      const z_power = inverseErf(2 * targetPower - 1) * Math.sqrt(2);

      const variance = mu + alpha * mu * mu;
      const effectSize = Math.abs(lfc);

      let n_est = (2 * variance * Math.pow(z_power + z_alpha, 2)) / (mu * mu * effectSize * effectSize);
      n_est = Math.ceil(n_est);
      if (n_est < 3) n_est = 3;

      document.getElementById("requiredSamples").innerText = `Estimated replicates per group needed to achieve ${(targetPower * 100).toFixed(0)}% power: ${n_est}`;
    }

    function drawPowerVsN(mu, alpha, lfc, fdr, rank, m) {
      const alphaTest = (fdr * rank) / m;
      const z_alpha = inverseErf(1 - alphaTest) * Math.sqrt(2);
      const x = [], y = [];
      for (let n = 3; n <= 30; n++) {
        const variance = mu + alpha * mu * mu;
        const se = Math.sqrt((2 / n) * variance / (mu * mu));
        const z = Math.abs(lfc) / se;
        const power = normCdf(z - z_alpha);
        x.push(n);
        y.push(power);
      }
      Plotly.newPlot("powerVsN", [{ x, y, type: 'scatter', name: 'Power vs Replicates' }], {
        title: 'Power vs Number of Replicates', xaxis: { title: 'Replicates per group' }, yaxis: { title: 'Power', range: [0, 1] }
      });
    }

    function drawPowerVsMu(n, alpha, lfc, fdr, rank, m) {
      const alphaTest = (fdr * rank) / m;
      const z_alpha = inverseErf(1 - alphaTest) * Math.sqrt(2);
      const x = [], y = [];
      for (let mu = 10; mu <= 500; mu += 10) {
        const variance = mu + alpha * mu * mu;
        const se = Math.sqrt((2 / n) * variance / (mu * mu));
        const z = Math.abs(lfc) / se;
        const power = normCdf(z - z_alpha);
        x.push(mu);
        y.push(power);
      }
      Plotly.newPlot("powerVsMu", [{ x, y, type: 'scatter', name: 'Power vs Expression' }], {
        title: 'Power vs Mean Expression (μ)', xaxis: { title: 'Mean expression (μ)' }, yaxis: { title: 'Power', range: [0, 1] }
      });
    }

    function drawPowerVsLFC(n, mu, alpha, fdr, rank, m) {
      const alphaTest = (fdr * rank) / m;
      const z_alpha = inverseErf(1 - alphaTest) * Math.sqrt(2);
      const x = [], y = [];
      for (let lfc = 0.2; lfc <= 3; lfc += 0.2) {
        const variance = mu + alpha * mu * mu;
        const se = Math.sqrt((2 / n) * variance / (mu * mu));
        const z = lfc / se;
        const power = normCdf(z - z_alpha);
        x.push(lfc);
        y.push(power);
      }
      Plotly.newPlot("powerVsLFC", [{ x, y, type: 'scatter', name: 'Power vs log2FC' }], {
        title: 'Power vs log2 Fold Change (Δ)', xaxis: { title: 'log2 Fold Change (Δ)' }, yaxis: { title: 'Power', range: [0, 1] }
      });
    }

    function drawPowerVsDisp(n, mu, lfc, fdr, rank, m) {
      const alphaTest = (fdr * rank) / m;
      const z_alpha = inverseErf(1 - alphaTest) * Math.sqrt(2);
      const x = [], y = [];
      for (let disp = 0.01; disp <= 0.5; disp += 0.02) {
        const variance = mu + disp * mu * mu;
        const se = Math.sqrt((2 / n) * variance / (mu * mu));
        const z = Math.abs(lfc) / se;
        const power = normCdf(z - z_alpha);
        x.push(disp);
        y.push(power);
      }
      Plotly.newPlot("powerVsDisp", [{ x, y, type: 'scatter', name: 'Power vs Dispersion' }], {
        title: 'Power vs Dispersion (α)', xaxis: { title: 'Dispersion (α)' }, yaxis: { title: 'Power', range: [0, 1] }
      });
    }
  </script></body>
</html>